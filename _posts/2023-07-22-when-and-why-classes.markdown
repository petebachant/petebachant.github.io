---
comments: true
layout: post
title: When and why to use classes (in Python anyway)
---

TL;DR: Classes are for encapsulating _long-lived_ application state,
and you want to minimize state, especially _mutable_ state,
so you should use classes as little as possible.

A disconcerting pattern I see somewhat often in the scientific/engineering
programming space is the use of classes to write procedures.
This seems appealing because it allows you to:

1. Reduce duplicate code through inheritance.
2. Store intermediate data for debugging, "encapsulating" all of the
   intermediate state in a single object.

However, both of these are actually bad from the standpoint of having
simple, readable, maintainable code.

Firstly, inheritance is bad. I won't explain here, but there's
plenty of material on this topic out there.
There are better ways to reduce duplicate code,
and duplicate code is preferable to code that requires jumping
from class-to-class, or worse, file-to-file, to understand.

So on the second point: Why would it be bad to encapsulate all of the
intermediate state generated by my procedure?
Basically, if you're creating a bunch of mutable state,
it's easy to create unintended and hard-to-debug side effects.

Let's take a look at an illustrative example,
and show how to simplify it.
Firstly, what does the interface look like?
A procedure written as a class usually involves
instantiating the object, calling one method on it,
and either throwing it away or keeping it around
but only using a small part of it, e.g., the result of a long-running
calculation.
The interface might look something like this:

```python
import my_simulation_tool

simulator = my_simulation_tool.Simulator(n_iterations=5)
simulator.simulate()
result = simulator.result
print(result)
```

In this example what we're interested in is the `result` object.
`Simulator` runs a procedure called `simulate` to generate this
and store what was generated internally as an attribute.
So, `Simulator` is not something we need to keep around, i.e.,
it is not long-lived state.
Classes are for encapsulating long-lived state,
so `Simulator` should not be a class.

A much more user-friendly interface (yes, this is subjective) would be:

```python
import my_simulation_tool

result = my_simulation_tool.simulate(n_iterations=5)
print(result)
```

We saved two lines of code, but more importantly, we reduced the amount
of state, and possibly the amount of mutable state.

What kinds of pitfalls could we encounter here?
What if we kept our `Simulator` around and ran it again?
Let's flesh out the code a bit to see what could be happening under the
hood and where we could go wrong:

```python
class Result:
    def __init__(self, force: list[int]):
        self.force = force

    @property
    def max_force(self):
        return max(self.force)

    def save(self, fpath: str):
        print("Saved to", fpath)


class Simulator:
    def __init__(self, n_iterations: int):
        self.n_iterations = n_iterations
        self.iteration = 0
        self.force = []

    def simulate(self):
        for _ in range(self.n_iterations):
            self.iteration += 1
            self.force.append(self.iteration)
        self.result = Result(force=self.force)


simulator = Simulator(n_iterations=5)
simulator.simulate()
result = simulator.result
result.save("my-file.csv")
print("Result max force:", result.max_force)
print("Result force:", result.force)
```

This would produce:

```
Saved to my-file.csv
Result max force: 5
Result force: [1, 2, 3, 4, 5]
```

What if we want to resimulate with more iterations to see if our result
is converged,
which is certainly something a scientist or engineer might do
as part of the verification process for their code.
Our app or script could look like:

```python
simulator = Simulator(n_iterations=5)
simulator.simulate()
result1 = simulator.result
print("Result 1 max force:", result1.max_force)
print("Result 1 force:", result1.force)
simulator.n_iterations = 10
simulator.simulate()
result2 = simulator.result
print("Result 2 max force:", result2.max_force)
print("Result 2 force:", result2.force)
print("Result 1 max force:", result1.max_force)
print("Result 1 force:", result1.force)
```

This would produce:

```
Result 1 max force: 5
Result 1 force: [1, 2, 3, 4, 5]
Result 2 max force: 15
Result 2 force: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
Result 1 max force: 15
Result 1 force: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
```

Two bad things happened here:
1. `result2` contained the data from 15 iterations, not 10, since some state
   was left behind inside `simulator` from the first run.
2. `result1` was mutated by the second run, making it not reflect the number
   of iterations run to generate it.

You might be saying "of course I wouldn't write classes like this!"
but the point is that using a class makes easier to make this mistake.
There are ways around this, e.g., by using private attributes
and using properties to reset state when necessary,
but why go through the trouble of keeping track of when this needs to happen?
Write the procedure as a procedure!

```python
class Result:
    def __init__(self, force: list[int]):
        self.force = force

    @property
    def max_force(self):
        return max(self.force)

    def save(self, fpath: str):
        print("Saved to", fpath)


def simulate(n_iterations: int) -> Result:
    iteration = 0
    force = []
    for _ in range(n_iterations):
        iteration += 1
        force.append(iteration)
    return Result(force=force)


result1 = simulate(n_iterations=5)
print("Result 1 max force:", result1.max_force)
print("Result 1 force:", result1.force)
result2 = simulate(n_iterations=10)
print("Result 2 max force:", result2.max_force)
print("Result 2 force:", result2.force)
print("Result 1 max force:", result1.max_force)
print("Result 1 force:", result1.force)
```

```
Result 1 max force: 5
Result 1 force: [1, 2, 3, 4, 5]
Result 2 max force: 10
Result 2 force: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Result 1 max force: 5
Result 1 force: [1, 2, 3, 4, 5]
```

This gives us the expected result with much less code
and much less mutable state.
Note we still have the `Result` class hanging around.
A result is potentially useful long-lived application
state, so using a class makes sense,
but it's still got a lot of mutable state, which could make it easy to
invalidate if we're careless.

As a bonus, let's make the result a little more immutable using
[`Pydantic`](https://docs.pydantic.dev/latest/),
an excellent package for defining custom data types,
which has an amazingly broad set of use cases.
We will also record some of the intermediate state in the result
for later debugging.
As a bonus, we don't need to define an `__init__` method for this
class, and get type-checking for free:

```python
from pydantic import BaseModel


class Result(BaseModel):
    force: list[int]
    n_iterations: int
    last_iteration: int

    @property
    def max_force(self) -> int:
        return max(self.force)

    def save(self, fpath: str):
        print("Saved to", fpath)


def simulate(n_iterations: int) -> Result:
    iteration = 0
    force = []
    for _ in range(n_iterations):
        iteration += 1
        force.append(iteration)
    return Result(
        force=force, n_iterations=n_iterations, last_iteration=iteration
    )
```

Writing things this way, we've saved a bunch of code,
saved our users from needing to instantiate classes
and therefore giving them the opportunity to misuse them,
and ultimately ended up with simpler software.

To wrap things up,
please don't write your procedures as classes,
and further, try to limit your use of classes to
only encapsulate state that is truly long-lived, and deserved its own
custom data type.

## Further exploration

1. [Stop writing classes](https://www.youtube.com/watch?v=o9pEzgHorH0)
2. [Object-Oriented Programming is Bad](https://www.youtube.com/watch?v=QM1iUe6IofM)
3. [Out of the tar pit](https://github.com/papers-we-love/papers-we-love/blob/main/design/out-of-the-tar-pit.pdf)
